**C++编程规范 - 101条规则、准则与最佳实现**

[toc]
# 组织和策略问题
## 第0条 不拘小节（了解哪些东西不应该标准化）
*只规定需要规定的部分，不影响程序正确性或可读性的问题不应该出现在规范中。*

个人建议：使用统一风格，不要混用
1. 缩进4空格
2. 一行长度在80~120之间，以不折行为准。
3. *大括号不换行*
4. 无异常的函数遵守SESE（Single Entry, Single Exit）规则

## 第1条 在高警告级别下干净利落地进行编译

*高度重视警告：使用编译器的最高警告级别。构建应该是干净利落的（没有警告。理解所有的警告，通过修改代码而不是降低警告级别来消除警告。*

警告意味着代码中有潜在的问题。

去除警告的建议：
> 1. 无法修改的库文件可以通过自定义一个头文件包含它，有选择的关闭警告
> 2. 如果一个函数的参数用不到，就不要写变量名，保留占位即可
> 3. 谨慎对待虚假警告，尽可能在局部关闭警告。

## 第2条 使用自动构建系统
*使用完全自动化（“单操作”）的构建系统，无需用户干预，无声无息，干净利落。*

增量编译要注意防止循环依赖。

一份代码通过不同的编译参数，一次运行完全构建

## 第3条 使用版本控制系统

*使用版本控制， 不要让文件长时间登出。单元测试通过后，尽快登入。不破坏构建，确保版本控制系统内的代码总能构建成功。*

## 第4条 代码审查
代码审查的好处：
> 1. 通过来自同伴的良性压力提高代码质量
> 2. 找出错误、不可移植的代码和潜在的问题
> 3. 通过思想交流获得更好的设计和实现
> 4. 快速培养新同事和入门者
> 5. 提升整体实力
> 6. 在团队中形成共同的价值观和集体主义

代码审查不可流于形式主义



# 设计风格
## 第5条 一个实体应该只有一个紧凑的职责

*一次只解决一个问题：只给一个实体（变量、类、函数、名称空间、模块和库）赋予一个定义良好的职责。随着实体变大，其职责范围自然也会扩大，但是职责不应该发散。*

应该选择目标单一的函数，小而且目的单一的类，边界清晰的紧凑模块。

用较小的低层抽象构建更高层次的抽象。



## 第6条 正确、简单和清晰第一

*软件简单为美：质量优于速度，简单优于复杂，清晰优于技巧，安全优于不安全。*

简单设计和清晰代码的价值怎么强调都不过分。

清晰性是易于维护、易于重构的程序最必须的特征

避免使用程序设计语言中的冷僻特性，应该使用最简单的有效技术。

使一个正确的程序变快，比使一个快速的程序正确容易的多。

## 第7条 编程中应该知道合适和如何考虑可伸缩性

*小心数据的爆炸性增长：不要进行不成熟的优化，但要密切关注渐近复杂性。处理用户数据的算法应该能够预测所处理数据的时间消耗。如果能够证明优化是必要的而且非常重要，应该集中精力改善算法复杂度。*

这是第8条和的第9条之间的一个平衡点。

## 第8条 不要进行不成熟的优化
## 第9条 不要进行不成熟劣化
## 第10条 尽量减少全局和共享数据
## 第11条 隐藏信息
## 第12条 懂得何时和如何进行并发编程
## 第13条 确保资源为对象所拥有，显示使用RAII和只能指针



# 编程风格
## 第14条
## 第15条
## 第16条
## 第17条
## 第18条
## 第19条
## 第20条
## 第21条
## 第22条
## 第23条
## 第24条



# 函数与操作符
## 第25条
## 第26条
## 第27条
## 第28条
## 第29条
## 第30条
## 第31条


# 类的设计与继承
## 第32条
## 第33条
## 第34条
## 第35条
## 第36条
## 第37条
## 第38条
## 第39条
## 第40条
## 第41条
## 第42条
## 第43条
## 第44条
## 第45条
## 第46条



# 构造、析构与复制
## 第47条
## 第48条
## 第49条
## 第50条
## 第51条
## 第52条
## 第53条
## 第54条
## 第55条
## 第56条


# 名称空间与模块
## 第条
## 第条
## 第条
## 第条


# 模板与泛型
## 第条
## 第条
## 第条
## 第条


# 错误处理与异常
## 第条
## 第条
## 第条
## 第条


# STL: 容器
## 第条
## 第条
## 第条
## 第条


# STL: 算法
## 第条
## 第条
## 第条
## 第条


# 类型安全
## 第条
## 第条
## 第条
## 第条

